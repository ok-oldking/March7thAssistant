name: Sync Fork and Flatten Submodules

on:
  workflow_dispatch: # Manual trigger
    inputs:
      branch:
        description: 'Branch in this fork to sync (e.g., main, master)'
        required: true
        default: 'main'
      upstream_repo_url:
        description: 'Full URL of the parent/upstream repository'
        required: true
        default: 'https://github.com/moesnow/March7thAssistant'
      upstream_branch:
        description: 'Branch in the upstream repo to sync from (e.g., main, master). If empty, uses the fork branch name.'
        required: false
        default: 'main'
  schedule:
    - cron: '0 3 * * *'
  push:
    branches:
      - main

env:
  DEFAULT_BRANCH: 'main'
  DEFAULT_UPSTREAM_REPO_URL: 'https://github.com/moesnow/March7thAssistant'
  DEFAULT_UPSTREAM_BRANCH: 'main'

jobs:
  sync_and_process:
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - name: Determine Sync Parameters
        id: sync_params
        run: |
          _branch=""
          _upstream_repo_url=""
          _upstream_branch=""
          echo "Event name: ${{ github.event_name }}"
          echo "Ref name: ${{ github.ref_name }}"
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            _branch="${{ github.event.inputs.branch }}"
            _upstream_repo_url="${{ github.event.inputs.upstream_repo_url }}"
            _upstream_branch="${{ github.event.inputs.upstream_branch || github.event.inputs.branch }}"
          elif [[ "${{ github.event_name }}" == "schedule" ]]; then
            _branch="${{ env.DEFAULT_BRANCH }}"
            _upstream_repo_url="${{ env.DEFAULT_UPSTREAM_REPO_URL }}"
            _upstream_branch="${{ env.DEFAULT_UPSTREAM_BRANCH }}"
          elif [[ "${{ github.event_name }}" == "push" ]]; then
            if [[ "${{ github.ref_name }}" == "${{ env.DEFAULT_BRANCH }}" ]]; then
              _branch="${{ github.ref_name }}"
              _upstream_repo_url="${{ env.DEFAULT_UPSTREAM_REPO_URL }}"
              _upstream_branch="${{ env.DEFAULT_UPSTREAM_BRANCH }}"
            else
              echo "Push event to non-default branch (${{ github.ref_name }}). Workflow configured for ${{ env.DEFAULT_BRANCH }}. Skipping."
              exit 0
            fi
          else
            echo "::error::Unsupported event type: ${{ github.event_name }}"
            exit 1
          fi
          if [[ -z "$_branch" ]]; then echo "::error::Target branch is not defined."; exit 1; fi
          if [[ -z "$_upstream_repo_url" ]]; then echo "::error::Upstream repository URL is not defined."; exit 1; fi
          if [[ -z "$_upstream_branch" ]]; then echo "::error::Upstream branch is not defined."; exit 1; fi
          echo "BRANCH_TO_SYNC=$_branch" >> $GITHUB_OUTPUT
          echo "UPSTREAM_REPO_URL=$_upstream_repo_url" >> $GITHUB_OUTPUT
          echo "UPSTREAM_BRANCH=$_upstream_branch" >> $GITHUB_OUTPUT

      - name: Checkout Fork
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.WORKFLOW }} 
          ref: ${{ steps.sync_params.outputs.BRANCH_TO_SYNC }}
          fetch-depth: 0
          submodules: false # We will handle submodules manually

      - name: Configure Git User
        run: |
          git config --global user.name "GitHub Action Sync Bot"
          git config --global user.email "actions@github.com"

      - name: Add Upstream Remote
        run: |
          git remote add upstream ${{ steps.sync_params.outputs.UPSTREAM_REPO_URL }} || echo "Upstream remote already exists or failed to add."
          git remote -v

      - name: Fetch from Upstream (including all tags)
        run: |
          echo "Fetching all tags from upstream and forcing local update..."
          git fetch upstream --tags --force
          echo "Fetching upstream branch ${{ steps.sync_params.outputs.UPSTREAM_BRANCH }}..."
          git fetch upstream ${{ steps.sync_params.outputs.UPSTREAM_BRANCH }}

      - name: Merge Upstream (Prefer Upstream on Conflict)
        run: |
          BRANCH="${{ steps.sync_params.outputs.BRANCH_TO_SYNC }}"
          UPSTREAM_BRANCH="${{ steps.sync_params.outputs.UPSTREAM_BRANCH }}"
          echo "Merging upstream/${UPSTREAM_BRANCH} into ${BRANCH}..."
          git merge "upstream/${UPSTREAM_BRANCH}" -X theirs --no-ff --no-commit --allow-unrelated-histories
          echo "Merge command executed. Changes from merge are staged. Submodule processing will follow before commit."

      - name: Prepare Temporary Upstream Clone for Submodules
        id: prep_upstream_clone
        run: |
          UPSTREAM_REPO_URL="${{ steps.sync_params.outputs.UPSTREAM_REPO_URL }}"
          UPSTREAM_BRANCH="${{ steps.sync_params.outputs.UPSTREAM_BRANCH }}"
          TEMP_UPSTREAM_DIR="upstream_temp_clone_for_submodules"

          echo "Cloning upstream ${UPSTREAM_REPO_URL} (branch ${UPSTREAM_BRANCH}) into ${TEMP_UPSTREAM_DIR}..."
          git clone --branch "${UPSTREAM_BRANCH}" --depth 1 "${UPSTREAM_REPO_URL}" "${TEMP_UPSTREAM_DIR}"
          
          cd "${TEMP_UPSTREAM_DIR}"
          if [ -f ".gitmodules" ]; then
            echo "Initializing submodules in temporary upstream clone (recursive, depth 1)..."
            git submodule update --init --recursive --depth 1
            echo "Submodules initialized in temporary clone."
            echo "submodules_present_in_temp_clone=true" >> $GITHUB_OUTPUT
          else
            echo "No .gitmodules file found in temporary upstream clone."
            echo "submodules_present_in_temp_clone=false" >> $GITHUB_OUTPUT
          fi
          echo "TEMP_UPSTREAM_CLONE_PATH=${GITHUB_WORKSPACE}/${TEMP_UPSTREAM_DIR}" >> $GITHUB_OUTPUT
          cd "${GITHUB_WORKSPACE}" 

      - name: Flatten/Inline Submodules from Upstream Clone
        id: flatten_submodules
        run: |
          echo "Attempting to inline submodules using content from temporary upstream clone..."
          changes_made_in_flatten=false
          TEMP_UPSTREAM_CLONE_PATH="${{ steps.prep_upstream_clone.outputs.TEMP_UPSTREAM_CLONE_PATH }}"
          SUBMODULES_PRESENT_IN_TEMP_CLONE="${{ steps.prep_upstream_clone.outputs.submodules_present_in_temp_clone }}"

          echo "De-initializing any existing submodule configurations in the main repo..."
          git submodule deinit --all -f 

          if [[ "$SUBMODULES_PRESENT_IN_TEMP_CLONE" != "true" ]]; then
            echo "Temporary upstream clone reported no .gitmodules or failed to initialize its submodules."
            echo "No submodules to inline from upstream."
          else
            echo "Processing submodules based on the .gitmodules file found in the temporary upstream clone..."
            # Parse .gitmodules from the TEMP_UPSTREAM_CLONE_PATH. Paths are relative to its root.
            if [ ! -f "${TEMP_UPSTREAM_CLONE_PATH}/.gitmodules" ]; then
                 echo "::warning:: SUBMODULES_PRESENT_IN_TEMP_CLONE was true, but ${TEMP_UPSTREAM_CLONE_PATH}/.gitmodules not found. This is unexpected."
            else
                # Ensure commands operate in the main repo's context (GITHUB_WORKSPACE)
                # Submodule paths read from upstream's .gitmodules are relative to the repo root.
                git -C "${TEMP_UPSTREAM_CLONE_PATH}" config --file .gitmodules --get-regexp path | awk '{ print $2 }' | while read -r submodule_path; do
                  echo "Processing submodule defined in upstream: $submodule_path"

                  # Define target path in the main repository (relative to GITHUB_WORKSPACE)
                  # Prefix with ./ to ensure it's treated as a relative path, especially for `git rm`.
                  target_submodule_path_in_main_repo="./${submodule_path}"
                  # Define source path of the fully checked-out submodule content in the temporary clone
                  source_submodule_content_path="${TEMP_UPSTREAM_CLONE_PATH}/${submodule_path}"

                  echo "Preparing target path '$target_submodule_path_in_main_repo' in main repo..."
                  # Remove from index if it was tracked as anything (file, gitlink, dir). Suppress errors if not found.
                  git rm -r --cached --ignore-unmatch "$target_submodule_path_in_main_repo" >/dev/null 2>&1
                  # Clean the working directory at that path thoroughly.
                  rm -rf "$target_submodule_path_in_main_repo"

                  if [ -d "$source_submodule_content_path" ]; then
                    echo "Copying content from ${source_submodule_content_path} to ${target_submodule_path_in_main_repo}..."
                    # Ensure parent directory exists in the main repo.
                    mkdir -p "$(dirname "$target_submodule_path_in_main_repo")"
                    # Copy content, excluding the submodule's .git directory.
                    rsync -a --delete --exclude='.git/' "${source_submodule_content_path}/" "${target_submodule_path_in_main_repo}/"

                    echo "Staging content of former submodule at $target_submodule_path_in_main_repo"
                    git add "$target_submodule_path_in_main_repo" # Add the new directory/files content
                    changes_made_in_flatten=true
                  else
                    echo "::warning::Submodule content for '${submodule_path}' not found at '${source_submodule_content_path}'. It might be an empty submodule or an issue with its initialization in the temp clone."
                  fi
                done
            fi
          fi

          # After processing all submodules from the temp clone,
          # if a .gitmodules file exists in the main repo's working directory or index, remove it.
          if git ls-files --error-unmatch .gitmodules >/dev/null 2>&1 || [ -f .gitmodules ]; then
            echo "Removing .gitmodules file from main repo..."
            git rm -f .gitmodules # Force removal from index and working tree if tracked
            rm -f .gitmodules     # Also ensure removal from working tree if it was untracked
            changes_made_in_flatten=true 
          else
            echo "No .gitmodules file found in the main repo to remove."
          fi
          
          echo "Submodule inlining process completed."
          echo "changes_made_in_flatten=$changes_made_in_flatten" >> $GITHUB_OUTPUT

      - name: Clean Up Temporary Upstream Clone
        if: always() 
        run: |
          TEMP_UPSTREAM_CLONE_PATH="${{ steps.prep_upstream_clone.outputs.TEMP_UPSTREAM_CLONE_PATH }}"
          if [ -n "$TEMP_UPSTREAM_CLONE_PATH" ] && [ -d "$TEMP_UPSTREAM_CLONE_PATH" ]; then
            echo "Removing temporary upstream clone at ${TEMP_UPSTREAM_CLONE_PATH}..."
            rm -rf "$TEMP_UPSTREAM_CLONE_PATH"
          else
            echo "Temporary upstream clone path not found or already removed."
          fi

      - name: Commit Changes
        id: commit
        run: |
          if ! git diff --name-only --diff-filter=U --quiet; then
            echo "::error::Unmerged paths found! This indicates a conflict that '-X theirs' could not resolve automatically."
            git status --short
            echo "Please resolve conflicts manually or investigate the merge strategy."
            exit 1
          fi

          COMMIT_MSG_BASE="Sync with upstream/${{ steps.sync_params.outputs.UPSTREAM_BRANCH }}, prefer upstream on conflict"
          FINAL_COMMIT_MSG="${COMMIT_MSG_BASE}"
          
          if [[ "${{ steps.flatten_submodules.outputs.changes_made_in_flatten }}" == "true" ]]; then
            FINAL_COMMIT_MSG="${COMMIT_MSG_BASE}}, and inlined submodules"
          fi

          # Check if there are any staged changes. All modifications (merge, submodule processing)
          # should have been staged by the respective steps.
          if git diff --quiet --cached; then
            echo "No changes staged for commit. This can happen if the fork is already up-to-date with upstream and no submodule processing was needed/done."
            echo "committed=false" >> $GITHUB_OUTPUT
          else
            echo "Staged changes detected. Committing with message: '${FINAL_COMMIT_MSG}'"
            git commit -m "${FINAL_COMMIT_MSG}"
            echo "Changes committed."
            echo "committed=true" >> $GITHUB_OUTPUT
          fi

      - name: Push Branch Changes
        if: steps.commit.outputs.committed == 'true'
        run: |
          BRANCH="${{ steps.sync_params.outputs.BRANCH_TO_SYNC }}"
          echo "Pushing branch changes to origin/${BRANCH}..."
          git push origin "${BRANCH}"

      - name: No Branch Changes to Push
        if: steps.commit.outputs.committed == 'false'
        run: echo "No branch changes were committed, so no branch push is necessary."

      - name: Push Synced Tags to Fork
        env:
          GH_TOKEN: ${{ secrets.WORKFLOW }} 
        run: |
          echo "Pushing all local tags (synced from upstream) to origin using PAT..."
          git push origin --tags --force 