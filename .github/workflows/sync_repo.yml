name: Sync Fork and Flatten Submodules

on:
  workflow_dispatch: # Manual trigger
    inputs:
      branch:
        description: 'Branch in this fork to sync (e.g., main, master)'
        required: true
        default: 'main'
      upstream_repo_url:
        description: 'Full URL of the parent/upstream repository'
        required: true
        default: 'https://github.com/moesnow/March7thAssistant'
      upstream_branch:
        description: 'Branch in the upstream repo to sync from (e.g., main, master). If empty, uses the fork branch name.'
        required: false
        default: 'main'
  schedule:
    - cron: '0 3 * * *'
  push:
    branches:
      - main

env:
  DEFAULT_BRANCH: 'main'
  DEFAULT_UPSTREAM_REPO_URL: 'https://github.com/moesnow/March7thAssistant'
  DEFAULT_UPSTREAM_BRANCH: 'main'

jobs:
  sync_and_process:
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - name: Determine Sync Parameters
        id: sync_params
        run: |
          _branch=""
          _upstream_repo_url=""
          _upstream_branch=""
          echo "Event name: ${{ github.event_name }}"
          echo "Ref name: ${{ github.ref_name }}"
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            _branch="${{ github.event.inputs.branch }}"
            _upstream_repo_url="${{ github.event.inputs.upstream_repo_url }}"
            _upstream_branch="${{ github.event.inputs.upstream_branch || github.event.inputs.branch }}"
          elif [[ "${{ github.event_name }}" == "schedule" ]]; then
            _branch="${{ env.DEFAULT_BRANCH }}"
            _upstream_repo_url="${{ env.DEFAULT_UPSTREAM_REPO_URL }}"
            _upstream_branch="${{ env.DEFAULT_UPSTREAM_BRANCH }}"
          elif [[ "${{ github.event_name }}" == "push" ]]; then
            if [[ "${{ github.ref_name }}" == "${{ env.DEFAULT_BRANCH }}" ]]; then
              _branch="${{ github.ref_name }}"
              _upstream_repo_url="${{ env.DEFAULT_UPSTREAM_REPO_URL }}"
              _upstream_branch="${{ env.DEFAULT_UPSTREAM_BRANCH }}"
            else
              echo "Push event to non-default branch (${{ github.ref_name }}). Workflow configured for ${{ env.DEFAULT_BRANCH }}. Skipping."
              exit 0
            fi
          else
            echo "::error::Unsupported event type: ${{ github.event_name }}"
            exit 1
          fi
          if [[ -z "$_branch" ]]; then echo "::error::Target branch is not defined."; exit 1; fi
          if [[ -z "$_upstream_repo_url" ]]; then echo "::error::Upstream repository URL is not defined."; exit 1; fi
          if [[ -z "$_upstream_branch" ]]; then echo "::error::Upstream branch is not defined."; exit 1; fi
          echo "BRANCH_TO_SYNC=$_branch" >> $GITHUB_OUTPUT
          echo "UPSTREAM_REPO_URL=$_upstream_repo_url" >> $GITHUB_OUTPUT
          echo "UPSTREAM_BRANCH=$_upstream_branch" >> $GITHUB_OUTPUT

      - name: Checkout Fork
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.WORKFLOW }} 
          ref: ${{ steps.sync_params.outputs.BRANCH_TO_SYNC }}
          fetch-depth: 0
          submodules: false # We will handle submodules manually

      - name: Configure Git User
        run: |
          git config --global user.name "GitHub Action Sync Bot"
          git config --global user.email "actions@github.com"

      - name: Add Upstream Remote
        run: |
          git remote add upstream ${{ steps.sync_params.outputs.UPSTREAM_REPO_URL }} || echo "Upstream remote already exists or failed to add."
          git remote -v

      - name: Fetch from Upstream (including all tags)
        run: |
          echo "Fetching all tags from upstream and forcing local update..."
          git fetch upstream --tags --force
          echo "Fetching upstream branch ${{ steps.sync_params.outputs.UPSTREAM_BRANCH }}..."
          git fetch upstream ${{ steps.sync_params.outputs.UPSTREAM_BRANCH }}

      - name: Merge Upstream (Prefer Upstream on Conflict)
        run: |
          BRANCH="${{ steps.sync_params.outputs.BRANCH_TO_SYNC }}"
          UPSTREAM_BRANCH="${{ steps.sync_params.outputs.UPSTREAM_BRANCH }}"
          echo "Merging upstream/${UPSTREAM_BRANCH} into ${BRANCH}..."
          git merge "upstream/${UPSTREAM_BRANCH}" -X theirs --no-ff --no-commit --allow-unrelated-histories
          echo "Merge command executed. .gitmodules and submodule references (if any) should now be from upstream."
          echo "Changes from merge are staged. Submodule processing will follow before commit."

      - name: Prepare Temporary Upstream Clone for Submodules
        id: prep_upstream_clone
        run: |
          UPSTREAM_REPO_URL="${{ steps.sync_params.outputs.UPSTREAM_REPO_URL }}"
          UPSTREAM_BRANCH="${{ steps.sync_params.outputs.UPSTREAM_BRANCH }}"
          TEMP_UPSTREAM_DIR="upstream_temp_clone_for_submodules"

          echo "Cloning upstream ${UPSTREAM_REPO_URL} (branch ${UPSTREAM_BRANCH}) into ${TEMP_UPSTREAM_DIR}..."
          # Using depth 1 for speed, as we only need the content at that commit
          git clone --branch "${UPSTREAM_BRANCH}" --depth 1 "${UPSTREAM_REPO_URL}" "${TEMP_UPSTREAM_DIR}"
          
          cd "${TEMP_UPSTREAM_DIR}"
          if [ -f ".gitmodules" ]; then
            echo "Initializing submodules in temporary upstream clone (recursive, depth 1)..."
            # Fetch submodules shallowly for speed
            git submodule update --init --recursive --depth 1
            echo "Submodules initialized in temporary clone."
            echo "submodules_present_in_temp_clone=true" >> $GITHUB_OUTPUT
          else
            echo "No .gitmodules file found in temporary upstream clone."
            echo "submodules_present_in_temp_clone=false" >> $GITHUB_OUTPUT
          fi
          # Output the absolute path to the temp clone for use in other steps
          echo "TEMP_UPSTREAM_CLONE_PATH=${GITHUB_WORKSPACE}/${TEMP_UPSTREAM_DIR}" >> $GITHUB_OUTPUT
          cd .. # Return to the original GITHUB_WORKSPACE

      - name: Flatten/Inline Submodules from Upstream Clone
        id: flatten_submodules
        run: |
          echo "Attempting to inline submodules using content from temporary upstream clone..."
          changes_made_in_flatten=false

          # This .gitmodules file is the one in the current repository,
          # which should be from the upstream after the merge.
          if [ ! -f ".gitmodules" ]; then
            echo "No .gitmodules file found in the current repository (branch ${{ steps.sync_params.outputs.BRANCH_TO_SYNC }}) after merge."
            echo "Skipping submodule inlining."
            echo "changes_made_in_flatten=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "De-initializing any existing submodule configurations in the main repo..."
          # This removes .git entries from submodules and unregisters them.
          git submodule deinit --all -f

          TEMP_UPSTREAM_CLONE_PATH="${{ steps.prep_upstream_clone.outputs.TEMP_UPSTREAM_CLONE_PATH }}"
          SUBMODULES_PRESENT_IN_TEMP_CLONE="${{ steps.prep_upstream_clone.outputs.submodules_present_in_temp_clone }}"

          if [[ "$SUBMODULES_PRESENT_IN_TEMP_CLONE" != "true" ]]; then
            echo "Temporary upstream clone reported no .gitmodules or failed to initialize submodules."
            echo "Only removing .gitmodules from current repo if it exists."
          else
            echo "Processing submodules listed in current repo's .gitmodules (sourced from upstream)..."
            # Parse .gitmodules from the current repository (which came from upstream via merge)
            git config --file .gitmodules --get-regexp path | awk '{ print $2 }' | while read -r submodule_path; do
              echo "Processing submodule: $submodule_path"

              echo "Removing existing content/gitlink at '$submodule_path' in main repo..."
              # Remove from index and working tree to avoid issues with adding new content
              git rm -rf --ignore-unmatch "$submodule_path" 
              # Ensure working directory is clean at this path
              rm -rf "$submodule_path" 
              
              source_submodule_content_path="${TEMP_UPSTREAM_CLONE_PATH}/${submodule_path}"

              if [ -d "$source_submodule_content_path" ]; then
                echo "Copying content from ${source_submodule_content_path} to ${submodule_path}..."
                mkdir -p "$(dirname "$submodule_path")" # Ensure parent directory exists
                # Copy content, excluding the submodule's .git directory
                rsync -a --delete --exclude='.git/' "${source_submodule_content_path}/" "${submodule_path}/"
                
                echo "Staging content of former submodule at $submodule_path"
                git add "$submodule_path"
                changes_made_in_flatten=true
              else
                echo "::warning::Submodule content not found at ${source_submodule_content_path} in the temporary upstream clone. It might be an empty submodule or an issue with its initialization in temp clone."
              fi
            done
          fi

          # If .gitmodules file still exists, remove it from staging and working directory
          if [ -f ".gitmodules" ]; then
            echo "Removing .gitmodules file from main repo..."
            git rm .gitmodules
            changes_made_in_flatten=true # Removing .gitmodules is a change
          fi
          
          echo "Submodule inlining process completed."
          echo "changes_made_in_flatten=$changes_made_in_flatten" >> $GITHUB_OUTPUT

      - name: Clean Up Temporary Upstream Clone
        if: always() # Ensure cleanup happens even if previous steps fail
        run: |
          TEMP_UPSTREAM_CLONE_PATH="${{ steps.prep_upstream_clone.outputs.TEMP_UPSTREAM_CLONE_PATH }}"
          if [ -n "$TEMP_UPSTREAM_CLONE_PATH" ] && [ -d "$TEMP_UPSTREAM_CLONE_PATH" ]; then
            echo "Removing temporary upstream clone at ${TEMP_UPSTREAM_CLONE_PATH}..."
            rm -rf "$TEMP_UPSTREAM_CLONE_PATH"
          else
            echo "Temporary upstream clone path not found or already removed."
          fi

      - name: Commit Changes
        id: commit
        run: |
          if ! git diff --name-only --diff-filter=U --quiet; then
            echo "::error::Unmerged paths found! This indicates a conflict that '-X theirs' could not resolve automatically."
            git status --short
            echo "Please resolve conflicts manually or investigate the merge strategy."
            exit 1
          fi

          COMMIT_MSG_BASE="Sync with upstream/${{ steps.sync_params.outputs.UPSTREAM_BRANCH }}, prefer upstream on conflict"
          FINAL_COMMIT_MSG="${COMMIT_MSG_BASE}"
          
          if [[ "${{ steps.flatten_submodules.outputs.changes_made_in_flatten }}" == "true" ]]; then
            FINAL_COMMIT_MSG="${COMMIT_MSG_BASE}, and inlined submodules"
          fi

          if git diff --quiet --cached; then
            echo "No changes staged for commit."
            echo "committed=false" >> $GITHUB_OUTPUT
          else
            echo "Staged changes detected. Committing with message: '${FINAL_COMMIT_MSG}'"
            git commit -m "${FINAL_COMMIT_MSG}"
            echo "Changes committed."
            echo "committed=true" >> $GITHUB_OUTPUT
          fi

      - name: Push Branch Changes
        if: steps.commit.outputs.committed == 'true'
        run: |
          BRANCH="${{ steps.sync_params.outputs.BRANCH_TO_SYNC }}"
          echo "Pushing branch changes to origin/${BRANCH}..."
          git push origin "${BRANCH}"

      - name: No Branch Changes to Push
        if: steps.commit.outputs.committed == 'false'
        run: echo "No branch changes were committed, so no branch push is necessary."

      - name: Push Synced Tags to Fork
        env:
          GH_TOKEN: ${{ secrets.WORKFLOW }} 
        run: |
          echo "Pushing all local tags (synced from upstream) to origin using PAT..."
          # The checkout step with 'token' should configure git for push,
          # but explicitly setting remote URL with PAT is a safeguard.
          # git remote set-url origin "https://x-access-token:${GH_TOKEN}@github.com/${{ github.repository }}.git"
          git push origin --tags --force # Use --force to overwrite tags if they were changed upstream