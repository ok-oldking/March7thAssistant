name: Sync Fork and Flatten Submodules

on:
  workflow_dispatch: # Manual trigger
    inputs:
      branch:
        description: 'Branch in this fork to sync (e.g., main, master)'
        required: true
        default: 'main'
      upstream_repo_url:
        description: 'Full URL of the parent/upstream repository'
        required: true
        default: 'https://github.com/moesnow/March7thAssistant'
      upstream_branch:
        description: 'Branch in the upstream repo to sync from (e.g., main, master). If empty, uses the fork branch name.'
        required: false
        default: 'main'
  schedule:
    - cron: '0 3 * * *'
  push:
    branches:
      - main # Or your default branch

env:
  DEFAULT_BRANCH: 'main' # Adjust if your default branch is different
  DEFAULT_UPSTREAM_REPO_URL: 'https://github.com/moesnow/March7thAssistant'
  DEFAULT_UPSTREAM_BRANCH: 'main'

jobs:
  sync_and_process:
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - name: Determine Sync Parameters
        id: sync_params
        run: |
          _branch=""
          _upstream_repo_url=""
          _upstream_branch=""
          echo "Event name: ${{ github.event_name }}"
          echo "Ref name: ${{ github.ref_name }}"
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            _branch="${{ github.event.inputs.branch }}"
            _upstream_repo_url="${{ github.event.inputs.upstream_repo_url }}"
            _upstream_branch="${{ github.event.inputs.upstream_branch || github.event.inputs.branch }}"
          elif [[ "${{ github.event_name }}" == "schedule" ]]; then
            _branch="${{ env.DEFAULT_BRANCH }}"
            _upstream_repo_url="${{ env.DEFAULT_UPSTREAM_REPO_URL }}"
            _upstream_branch="${{ env.DEFAULT_UPSTREAM_BRANCH }}"
          elif [[ "${{ github.event_name }}" == "push" ]]; then
            # Only run on push to the specified default branch for safety,
            # or if you want to sync other branches, adjust this logic.
            if [[ "${{ github.ref_name }}" == "${{ env.DEFAULT_BRANCH }}" ]]; then
              _branch="${{ github.ref_name }}"
              _upstream_repo_url="${{ env.DEFAULT_UPSTREAM_REPO_URL }}"
              _upstream_branch="${{ env.DEFAULT_UPSTREAM_BRANCH }}"
            else
              echo "Push event to non-default branch (${{ github.ref_name }}). Workflow configured for ${{ env.DEFAULT_BRANCH }}. Skipping."
              exit 0 # Use 78 for neutral exit if you prefer
            fi
          else
            echo "::error::Unsupported event type: ${{ github.event_name }}"
            exit 1
          fi
          if [[ -z "$_branch" ]]; then echo "::error::Target branch is not defined."; exit 1; fi
          if [[ -z "$_upstream_repo_url" ]]; then echo "::error::Upstream repository URL is not defined."; exit 1; fi
          if [[ -z "$_upstream_branch" ]]; then echo "::error::Upstream branch is not defined."; exit 1; fi
          echo "BRANCH_TO_SYNC=$_branch" >> $GITHUB_OUTPUT
          echo "UPSTREAM_REPO_URL=$_upstream_repo_url" >> $GITHUB_OUTPUT
          echo "UPSTREAM_BRANCH=$_upstream_branch" >> $GITHUB_OUTPUT

      - name: Checkout Fork
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.WORKFLOW }} # Use a PAT with repo write access
          ref: ${{ steps.sync_params.outputs.BRANCH_TO_SYNC }}
          fetch-depth: 0 # Needed for merge history and tags
          submodules: false # We will handle submodules manually

      - name: Configure Git User
        run: |
          git config --global user.name "GitHub Action Sync Bot"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

      - name: Add Upstream Remote
        run: |
          git remote add upstream ${{ steps.sync_params.outputs.UPSTREAM_REPO_URL }} || echo "Upstream remote already exists or failed to add."
          git remote -v

      - name: Fetch from Upstream (including all tags)
        run: |
          echo "Fetching all tags from upstream and forcing local update..."
          git fetch upstream --tags --force
          echo "Fetching upstream branch ${{ steps.sync_params.outputs.UPSTREAM_BRANCH }}..."
          git fetch upstream ${{ steps.sync_params.outputs.UPSTREAM_BRANCH }}

      - name: Prepare Temporary Upstream Clone for Submodule Info
        id: prep_upstream_clone # Renamed for clarity, similar to before
        run: |
          UPSTREAM_REPO_URL="${{ steps.sync_params.outputs.UPSTREAM_REPO_URL }}"
          UPSTREAM_BRANCH="${{ steps.sync_params.outputs.UPSTREAM_BRANCH }}"
          TEMP_UPSTREAM_DIR="upstream_temp_clone_for_submodules"

          echo "Cloning upstream ${UPSTREAM_REPO_URL} (branch ${UPSTREAM_BRANCH}) into ${TEMP_UPSTREAM_DIR}..."
          # Clone without initializing submodules here, just need .gitmodules and submodule content later
          git clone --branch "${UPSTREAM_BRANCH}" --depth 1 --no-recurse-submodules "${UPSTREAM_REPO_URL}" "${TEMP_UPSTREAM_DIR}"
          
          cd "${TEMP_UPSTREAM_DIR}"
          if [ -f ".gitmodules" ]; then
            echo "Initializing submodules in temporary upstream clone (recursive, depth 1)..."
            git submodule update --init --recursive --depth 1 # Now initialize them
            echo "Submodules initialized in temporary clone."
            echo "submodules_present_in_temp_clone=true" >> $GITHUB_OUTPUT
          else
            echo "No .gitmodules file found in temporary upstream clone."
            echo "submodules_present_in_temp_clone=false" >> $GITHUB_OUTPUT
          fi
          echo "TEMP_UPSTREAM_CLONE_PATH=${GITHUB_WORKSPACE}/${TEMP_UPSTREAM_DIR}" >> $GITHUB_OUTPUT
          cd "${GITHUB_WORKSPACE}"

      - name: Clean Local Submodule Paths Before Merge
        run: |
          echo "Cleaning potential submodule paths in local repo before merging upstream..."
          TEMP_UPSTREAM_CLONE_PATH="${{ steps.prep_upstream_clone.outputs.TEMP_UPSTREAM_CLONE_PATH }}"
          SUBMODULES_PRESENT_IN_TEMP_CLONE="${{ steps.prep_upstream_clone.outputs.submodules_present_in_temp_clone }}"

          if [[ "$SUBMODULES_PRESENT_IN_TEMP_CLONE" == "true" ]]; then
            if [ -f "${TEMP_UPSTREAM_CLONE_PATH}/.gitmodules" ]; then
              # Parse .gitmodules from the TEMP_UPSTREAM_CLONE_PATH.
              git -C "${TEMP_UPSTREAM_CLONE_PATH}" config --file .gitmodules --get-regexp path | awk '{ print $2 }' | while read -r submodule_path; do
                echo "Pre-emptively cleaning path in main repo: $submodule_path"
                target_path_in_main_repo="./${submodule_path}" # Ensure relative path context

                # Remove from index if it was tracked as anything (file, gitlink, dir). Suppress errors.
                git rm -r --cached --ignore-unmatch "$target_path_in_main_repo" >/dev/null 2>&1
                # Clean the working directory at that path thoroughly.
                if [ -e "$target_path_in_main_repo" ]; then # Check if file or directory exists
                    echo "Removing existing content at $target_path_in_main_repo"
                    rm -rf "$target_path_in_main_repo"
                fi
              done
            else
              echo "::warning:: SUBMODULES_PRESENT_IN_TEMP_CLONE was true, but ${TEMP_UPSTREAM_CLONE_PATH}/.gitmodules not found."
            fi
          else
            echo "No submodules indicated by upstream's temp clone. No pre-emptive cleaning of specific paths needed."
          fi
          
          # Also ensure .gitmodules from the fork is gone before merge, in case upstream removed theirs.
          if git ls-files --error-unmatch .gitmodules >/dev/null 2>&1 || [ -f .gitmodules ]; then
            echo "Removing .gitmodules file from main repo before merge..."
            git rm -f --ignore-unmatch .gitmodules >/dev/null 2>&1
            rm -f .gitmodules
          fi
          echo "Local paths cleaned."


      - name: Merge Upstream (Prefer Upstream on Conflict)
        run: |
          BRANCH="${{ steps.sync_params.outputs.BRANCH_TO_SYNC }}"
          UPSTREAM_BRANCH="${{ steps.sync_params.outputs.UPSTREAM_BRANCH }}"
          echo "Merging upstream/${UPSTREAM_BRANCH} into ${BRANCH}..."
          # --no-ff creates a merge commit, --no-commit stages changes allowing further processing
          git merge "upstream/${UPSTREAM_BRANCH}" -X theirs --no-ff --no-commit --allow-unrelated-histories
          echo "Merge command executed. Changes from merge are staged. Submodule processing will follow before commit."

      - name: Flatten/Inline Submodules from Upstream Clone
        id: flatten_submodules
        run: |
          echo "Attempting to inline submodules using content from temporary upstream clone..."
          changes_made_in_flatten=false
          TEMP_UPSTREAM_CLONE_PATH="${{ steps.prep_upstream_clone.outputs.TEMP_UPSTREAM_CLONE_PATH }}"
          SUBMODULES_PRESENT_IN_TEMP_CLONE="${{ steps.prep_upstream_clone.outputs.submodules_present_in_temp_clone }}"

          echo "De-initializing any submodule configurations that might have been merged in..."
          # This will remove any .git entries for submodules and convert them to plain directories if they had content,
          # or remove the gitlinks if they were just pointers.
          git submodule deinit --all -f 

          if [[ "$SUBMODULES_PRESENT_IN_TEMP_CLONE" != "true" ]]; then
            echo "Temporary upstream clone reported no .gitmodules or failed to initialize its submodules."
            echo "No submodules to inline from upstream."
          else
            echo "Processing submodules based on the .gitmodules file found in the temporary upstream clone..."
            if [ ! -f "${TEMP_UPSTREAM_CLONE_PATH}/.gitmodules" ]; then
                 echo "::warning:: SUBMODULES_PRESENT_IN_TEMP_CLONE was true, but ${TEMP_UPSTREAM_CLONE_PATH}/.gitmodules not found. This is unexpected."
            else
                git -C "${TEMP_UPSTREAM_CLONE_PATH}" config --file .gitmodules --get-regexp path | awk '{ print $2 }' | while read -r submodule_path; do
                  echo "Processing submodule defined in upstream: $submodule_path"
                  target_submodule_path_in_main_repo="./${submodule_path}"
                  source_submodule_content_path="${TEMP_UPSTREAM_CLONE_PATH}/${submodule_path}"

                  echo "Ensuring target path '$target_submodule_path_in_main_repo' is clean in main repo..."
                  # Remove from index if it's still tracked somehow (e.g. as an empty dir after deinit)
                  git rm -r --cached --ignore-unmatch "$target_submodule_path_in_main_repo" >/dev/null 2>&1
                  # Physically clean the directory again, just in case deinit left an empty folder
                  rm -rf "$target_submodule_path_in_main_repo"

                  if [ -d "$source_submodule_content_path" ] && [ -n "$(ls -A "$source_submodule_content_path")" ]; then # Check if dir exists and is not empty
                    echo "Copying content from ${source_submodule_content_path} to ${target_submodule_path_in_main_repo}..."
                    mkdir -p "$(dirname "$target_submodule_path_in_main_repo")"
                    rsync -a --delete --exclude='.git/' "${source_submodule_content_path}/" "${target_submodule_path_in_main_repo}/"

                    echo "Staging content of former submodule at $target_submodule_path_in_main_repo"
                    git add "$target_submodule_path_in_main_repo"
                    changes_made_in_flatten=true
                  else
                    echo "::warning::Submodule content for '${submodule_path}' not found at '${source_submodule_content_path}' or is empty. It might be an empty submodule or an issue with its initialization in the temp clone."
                  fi
                done
            fi
          fi

          if git ls-files --error-unmatch .gitmodules >/dev/null 2>&1 || [ -f .gitmodules ]; then
            echo "Removing .gitmodules file from main repo (post-flattening)..."
            git rm -f --ignore-unmatch .gitmodules >/dev/null 2>&1 # from index
            rm -f .gitmodules     # from worktree
            changes_made_in_flatten=true 
          else
            echo "No .gitmodules file found in the main repo to remove (post-flattening)."
          fi
          
          echo "Submodule inlining process completed."
          echo "changes_made_in_flatten=$changes_made_in_flatten" >> $GITHUB_OUTPUT

      - name: Clean Up Temporary Upstream Clone
        if: always() 
        run: |
          TEMP_UPSTREAM_CLONE_PATH="${{ steps.prep_upstream_clone.outputs.TEMP_UPSTREAM_CLONE_PATH }}"
          if [ -n "$TEMP_UPSTREAM_CLONE_PATH" ] && [ -d "$TEMP_UPSTREAM_CLONE_PATH" ]; then
            echo "Removing temporary upstream clone at ${TEMP_UPSTREAM_CLONE_PATH}..."
            rm -rf "$TEMP_UPSTREAM_CLONE_PATH"
          else
            echo "Temporary upstream clone path not found or already removed."
          fi

      - name: Commit Changes
        id: commit
        run: |
          # Check for unmerged paths from the merge step (should not happen with -X theirs but good check)
          if ! git diff --name-only --diff-filter=U --quiet; then
            echo "::error::Unmerged paths found after 'git merge -X theirs'! This is unexpected."
            git status --short
            git diff --name-only --diff-filter=U
            echo "Please investigate the merge strategy or pre-clean step."
            exit 1
          fi

          COMMIT_MSG_BASE="Sync with upstream/${{ steps.sync_params.outputs.UPSTREAM_BRANCH }}, prefer upstream on conflict"
          FINAL_COMMIT_MSG="${COMMIT_MSG_BASE}"
          
          if [[ "${{ steps.flatten_submodules.outputs.changes_made_in_flatten }}" == "true" ]]; then
            FINAL_COMMIT_MSG="${COMMIT_MSG_BASE}}, and inlined submodules"
          fi

          # Check if there are any staged changes.
          # `git diff --quiet --cached` exits with 0 if no staged changes, 1 if there are.
          if git diff --quiet --cached; then
            # Also check for untracked files that should have been added (e.g. new flattened submodules)
            # or working tree changes that were not staged.
            # However, all our operations should be staging changes.
            # This condition means merge + flattening resulted in no net change compared to HEAD before merge.
            echo "No changes staged for commit. Fork is likely already up-to-date and submodules correctly flattened."
            echo "committed=false" >> $GITHUB_OUTPUT
          else
            echo "Staged changes detected. Committing with message: '${FINAL_COMMIT_MSG}'"
            git commit -m "${FINAL_COMMIT_MSG}"
            echo "Changes committed."
            echo "committed=true" >> $GITHUB_OUTPUT
          fi

      - name: Push Branch Changes
        if: steps.commit.outputs.committed == 'true'
        run: |
          BRANCH="${{ steps.sync_params.outputs.BRANCH_TO_SYNC }}"
          echo "Pushing branch changes to origin/${BRANCH}..."
          git push origin "${BRANCH}"

      - name: No Branch Changes to Push
        if: steps.commit.outputs.committed == 'false'
        run: echo "No branch changes were committed, so no branch push is necessary."

      - name: Push Synced Tags to Fork
        # Always try to push tags, as upstream tags might have been fetched even if no branch changes
        env:
          GH_TOKEN: ${{ secrets.WORKFLOW }} 
        run: |
          echo "Pushing all local tags (synced from upstream) to origin using PAT..."
          # --force is used because upstream might have force-pushed tags or deleted tags
          # which we want to reflect in the fork.
          git push origin --tags --force